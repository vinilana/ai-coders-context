/**
 * PREVC Workflow Orchestrator
 *
 * Manages workflow progression, phase transitions, and role handoffs.
 */

import * as fs from 'fs-extra';
import * as path from 'path';
import {
  PrevcStatus,
  PrevcPhase,
  PrevcRole,
  ProjectContext,
  ProjectScale,
  WorkflowSettings,
  PlanApproval,
} from './types';
import { PrevcStatusManager } from './status/statusManager';
import { detectProjectScale, getScaleRoute } from './scaling';
import { PREVC_PHASE_ORDER, getPhaseDefinition } from './phases';
import { getRoleConfig } from './prevcConfig';
import { WorkflowGateChecker, GateCheckResult, getDefaultSettings } from './gates';
import { PlanLinker } from './plans/planLinker';

/**
 * Options for completing a phase
 */
export interface CompletePhaseOptions {
  /** Force advancement even if gates would block */
  force?: boolean;
}

/**
 * Options for initializing a workflow with settings
 */
export interface InitWorkflowOptions {
  name: string;
  scale: ProjectScale;
  /** Override default settings */
  settings?: Partial<WorkflowSettings>;
}

/**
 * PREVC Workflow Orchestrator
 *
 * Coordinates the execution of the PREVC workflow.
 */
export class PrevcOrchestrator {
  private contextPath: string;
  private statusManager: PrevcStatusManager;
  private gateChecker: WorkflowGateChecker;
  private planLinker: PlanLinker;

  constructor(contextPath: string) {
    this.contextPath = contextPath;
    this.statusManager = new PrevcStatusManager(contextPath);
    this.gateChecker = new WorkflowGateChecker();
    this.planLinker = new PlanLinker(path.dirname(contextPath));
  }

  /**
   * Check if a workflow exists
   */
  async hasWorkflow(): Promise<boolean> {
    return this.statusManager.exists();
  }

  /**
   * Initialize a new workflow
   */
  async initWorkflow(context: ProjectContext): Promise<PrevcStatus> {
    const scale = detectProjectScale(context);
    const route = getScaleRoute(scale);

    return this.statusManager.create({
      name: context.name,
      scale,
      phases: route.phases,
      roles: route.roles,
    });
  }

  /**
   * Initialize a workflow with explicit scale
   * @param archivePrevious - If undefined and workflow exists, throws error. If true, archives. If false, deletes.
   */
  async initWorkflowWithScale(
    name: string,
    scale: ProjectScale,
    settings?: Partial<WorkflowSettings>,
    archivePrevious?: boolean
  ): Promise<PrevcStatus> {
    // Check for existing workflow
    if (await this.hasWorkflow()) {
      if (archivePrevious === undefined) {
        throw new Error(
          'A workflow already exists. Use archivePrevious=true to archive or archivePrevious=false to delete the existing workflow.'
        );
      }
      await this.resetWorkflow(archivePrevious);
    }

    const route = getScaleRoute(scale);

    const status = await this.statusManager.create({
      name,
      scale,
      phases: route.phases,
      roles: route.roles,
    });

    // Apply custom settings if provided
    if (settings) {
      await this.statusManager.setSettings(settings);
      return this.statusManager.load();
    }

    return status;
  }

  /**
   * Reset the current workflow
   * @param archive - If true, archives the current workflow. If false, deletes it.
   */
  async resetWorkflow(archive: boolean): Promise<void> {
    if (archive) {
      await this.archiveCurrentWorkflow();
      await this.planLinker.archivePlans();
    } else {
      await this.planLinker.clearAllPlans();
      // Delete status.yaml
      const statusPath = path.join(this.contextPath, 'workflow', 'status.yaml');
      if (await fs.pathExists(statusPath)) {
        await fs.remove(statusPath);
      }
    }
  }

  /**
   * Archive the current workflow to .context/workflow/archive/
   */
  private async archiveCurrentWorkflow(): Promise<void> {
    const workflowPath = path.join(this.contextPath, 'workflow');
    const statusPath = path.join(workflowPath, 'status.yaml');

    if (!(await fs.pathExists(statusPath))) {
      return;
    }

    // Get current workflow name for archive folder
    let archiveName = 'workflow';
    try {
      const status = await this.statusManager.load();
      archiveName = status.project.name.replace(/[^a-zA-Z0-9-_]/g, '-');
    } catch {
      // Use default name if can't load status
    }

    const timestamp = new Date().toISOString().replace(/[:.]/g, '-');
    const archiveDir = path.join(workflowPath, 'archive', `${archiveName}-${timestamp}`);

    await fs.ensureDir(archiveDir);

    // Move status.yaml to archive
    await fs.move(statusPath, path.join(archiveDir, 'status.yaml'));
  }

  /**
   * Initialize a workflow with full options
   */
  async initWorkflowWithOptions(options: InitWorkflowOptions): Promise<PrevcStatus> {
    return this.initWorkflowWithScale(options.name, options.scale, options.settings);
  }

  /**
   * Get the current workflow status
   */
  async getStatus(): Promise<PrevcStatus> {
    return this.statusManager.load();
  }

  /**
   * Get the current phase
   */
  async getCurrentPhase(): Promise<PrevcPhase> {
    return this.statusManager.getCurrentPhase();
  }

  /**
   * Get the current active role
   */
  async getCurrentRole(): Promise<PrevcRole | null> {
    return this.statusManager.getActiveRole();
  }

  /**
   * Get the phase definition for the current phase
   */
  async getCurrentPhaseDefinition() {
    const phase = await this.getCurrentPhase();
    return getPhaseDefinition(phase);
  }

  /**
   * Perform a handoff from one role to another
   */
  async handoff(
    from: PrevcRole,
    to: PrevcRole,
    artifacts: string[]
  ): Promise<void> {
    // Update the outgoing role
    await this.statusManager.updateRole(from, {
      status: 'completed',
      outputs: artifacts,
    });

    // Update the incoming role
    await this.statusManager.updateRole(to, {
      status: 'in_progress',
    });
  }

  /**
   * Complete the current phase and advance to the next
   */
  async completePhase(
    outputs?: string[],
    options: CompletePhaseOptions = {}
  ): Promise<PrevcPhase | null> {
    const status = await this.getStatus();
    const currentPhase = status.project.current_phase;
    const nextPhase = await this.getNextPhase();

    // Check gates before advancing (unless force is true)
    if (nextPhase) {
      this.gateChecker.enforceGates(status, {
        force: options.force,
        nextPhase,
      });
    }

    // Mark current phase as complete
    await this.statusManager.markPhaseComplete(currentPhase, outputs);

    // Auto-sync linked plan markdown with execution progress
    if (status.project.plan) {
      try {
        await this.planLinker.syncPlanMarkdown(status.project.plan);
      } catch {
        // Silent fail - plan sync is non-critical
      }
    }

    // Get and transition to next phase
    if (nextPhase) {
      await this.statusManager.transitionToPhase(nextPhase);
    }

    return nextPhase;
  }

  /**
   * Check gates for the current phase transition
   */
  async checkGates(): Promise<GateCheckResult> {
    const status = await this.getStatus();
    return this.gateChecker.checkGates(status);
  }

  /**
   * Set workflow settings
   */
  async setSettings(settings: Partial<WorkflowSettings>): Promise<WorkflowSettings> {
    return this.statusManager.setSettings(settings);
  }

  /**
   * Get workflow settings
   */
  async getSettings(): Promise<WorkflowSettings> {
    return this.statusManager.getSettings();
  }

  /**
   * Mark that a plan has been created/linked
   */
  async markPlanCreated(planSlug: string): Promise<void> {
    return this.statusManager.markPlanCreated(planSlug);
  }

  /**
   * Approve the plan
   */
  async approvePlan(approver: PrevcRole | string, notes?: string): Promise<PlanApproval> {
    return this.statusManager.approvePlan(approver, notes);
  }

  /**
   * Get approval status
   */
  async getApproval(): Promise<PlanApproval | undefined> {
    return this.statusManager.getApproval();
  }

  /**
   * Advance to the next phase
   */
  async advanceToNextPhase(): Promise<PrevcPhase | null> {
    const nextPhase = await this.getNextPhase();
    if (nextPhase) {
      await this.statusManager.transitionToPhase(nextPhase);
    }
    return nextPhase;
  }

  /**
   * Get the next phase that should be executed
   */
  async getNextPhase(): Promise<PrevcPhase | null> {
    return this.statusManager.getNextPhase();
  }

  /**
   * Check if the workflow is complete
   */
  async isComplete(): Promise<boolean> {
    return this.statusManager.isComplete();
  }

  /**
   * Get recommended next actions for the current state
   */
  async getRecommendedActions(): Promise<string[]> {
    const status = await this.getStatus();
    const currentPhase = status.project.current_phase;
    const phaseDefinition = getPhaseDefinition(currentPhase);
    const actions: string[] = [];

    // Suggest phase-specific actions
    actions.push(
      `Complete ${phaseDefinition.name} phase tasks`
    );

    // Suggest role-specific actions
    for (const role of phaseDefinition.roles) {
      const roleConfig = getRoleConfig(role);
      if (roleConfig) {
        actions.push(...roleConfig.responsibilities.slice(0, 2));
      }
    }

    // Suggest output creation
    if (phaseDefinition.outputs.length > 0) {
      actions.push(
        `Create outputs: ${phaseDefinition.outputs.join(', ')}`
      );
    }

    return actions;
  }

  /**
   * Get a summary of the current workflow state
   */
  async getSummary(): Promise<WorkflowSummary> {
    const status = await this.getStatus();
    const isComplete = await this.isComplete();

    // Count completed phases
    let completedPhases = 0;
    let totalPhases = 0;

    for (const phase of PREVC_PHASE_ORDER) {
      if (status.phases[phase].status !== 'skipped') {
        totalPhases++;
        if (status.phases[phase].status === 'completed') {
          completedPhases++;
        }
      }
    }

    return {
      name: status.project.name,
      scale: status.project.scale,
      currentPhase: status.project.current_phase,
      progress: {
        completed: completedPhases,
        total: totalPhases,
        percentage: Math.round((completedPhases / totalPhases) * 100),
      },
      isComplete,
      startedAt: status.project.started,
    };
  }

  /**
   * Update the current task description
   */
  async updateCurrentTask(task: string): Promise<void> {
    const currentPhase = await this.getCurrentPhase();
    const activeRole = await this.getCurrentRole();

    await this.statusManager.updatePhase(currentPhase, {
      current_task: task,
      role: activeRole || undefined,
    });
  }

  /**
   * Start a specific role in the current phase
   */
  async startRole(role: PrevcRole): Promise<void> {
    const currentPhase = await this.getCurrentPhase();

    await this.statusManager.updateRole(role, {
      status: 'in_progress',
      phase: currentPhase,
    });

    await this.statusManager.updatePhase(currentPhase, {
      role,
    });
  }

  /**
   * Complete a role's work in the current phase
   */
  async completeRole(role: PrevcRole, outputs: string[]): Promise<void> {
    await this.statusManager.updateRole(role, {
      status: 'completed',
      outputs,
      last_active: new Date().toISOString(),
    });
  }
}

/**
 * Workflow summary for display
 */
export interface WorkflowSummary {
  name: string;
  scale: ProjectScale | keyof typeof ProjectScale;
  currentPhase: PrevcPhase;
  progress: {
    completed: number;
    total: number;
    percentage: number;
  };
  isComplete: boolean;
  startedAt: string;
}
