/**
 * Workflow Manage Handler
 *
 * Handles workflow management operations: handoffs, collaboration, documents, gates, approvals.
 */

import * as path from 'path';
import { WorkflowService } from '../../workflow';
import { resolveContextRoot } from '../../shared/contextRootResolver';
import {
  PHASE_NAMES_EN,
  ROLE_DISPLAY_NAMES,
  createPlanLinker,
} from '../../../workflow';

import type { PrevcRole } from '../../../workflow';
import type { MCPToolResponse } from './response';
import { createJsonResponse, createErrorResponse } from './response';

export interface WorkflowManageParams {
  action: 'handoff' | 'collaborate' | 'createDoc' | 'getGates' | 'approvePlan' | 'setAutonomous';
  from?: string;
  to?: string;
  artifacts?: string[];
  topic?: string;
  participants?: PrevcRole[];
  type?: 'prd' | 'tech-spec' | 'architecture' | 'adr' | 'test-plan' | 'changelog';
  docName?: string;
  planSlug?: string;
  approver?: PrevcRole;
  notes?: string;
  enabled?: boolean;
  reason?: string;
  repoPath?: string;
}

export interface WorkflowManageOptions {
  repoPath: string;
}

/**
 * Manage workflow operations: handoffs, collaboration, documents, gates, approvals.
 */
export async function handleWorkflowManage(
  params: WorkflowManageParams,
  options: WorkflowManageOptions
): Promise<MCPToolResponse> {
  try {
    // Resolve repo path with robust context detection
    let repoPath = params.repoPath || options.repoPath;
    if (!repoPath) {
      const resolution = await resolveContextRoot({ validate: false });
      repoPath = resolution.projectRoot;
    }
    repoPath = path.resolve(repoPath);

    // Create service with robust detection
    const service = await WorkflowService.create(repoPath);

    switch (params.action) {
      case 'handoff': {
        if (!(await service.hasWorkflow())) {
          return createJsonResponse({
            success: false,
            error: 'No workflow found. Initialize a workflow first.',
            suggestion: 'Use workflow-init({ name: "feature-name" }) to start.',
          });
        }

        // Validate required parameters for agent handoff
        if (!params.from || !params.to) {
          return createJsonResponse({
            success: false,
            error: 'handoff requires from and to agent names',
          });
        }

        await service.handoff(params.from, params.to, params.artifacts || []);

        // Get next agent suggestion
        const nextSuggestion = service.getNextAgentSuggestion(params.to);

        return createJsonResponse({
          success: true,
          message: `Handoff complete: ${params.from} â†’ ${params.to}`,
          handoff: {
            from: params.from,
            to: params.to,
            artifacts: params.artifacts || [],
          },
          nextSuggestion,
        });
      }

      case 'collaborate': {
        const session = await service.startCollaboration(
          params.topic!,
          params.participants
        );
        const sessionStatus = session.getStatus();

        return createJsonResponse({
          success: true,
          message: `Collaboration session started: ${params.topic}`,
          sessionId: sessionStatus.id,
          topic: sessionStatus.topic,
          participants: sessionStatus.participants.map((p) => ({
            role: p,
            displayName: ROLE_DISPLAY_NAMES[p],
          })),
        });
      }

      case 'createDoc': {
        if (!(await service.hasWorkflow())) {
          return createJsonResponse({
            success: false,
            error: 'No workflow found. Initialize a workflow first.',
            suggestion: 'Use workflow-init({ name: "feature-name" }) to start.',
          });
        }

        const docPath = `.context/workflow/docs/${params.type}-${params.docName?.toLowerCase().replace(/\s+/g, '-')}.md`;

        return createJsonResponse({
          success: true,
          message: `Document template ready: ${params.type}`,
          documentType: params.type,
          suggestedPath: docPath,
          name: params.docName,
        });
      }

      case 'getGates': {
        if (!(await service.hasWorkflow())) {
          return createJsonResponse({
            success: false,
            error: 'No workflow found. Initialize a workflow first.',
            suggestion: 'Use workflow-init({ name: "feature-name" }) to start.',
          });
        }

        const gateResult = await service.checkGates();
        const settings = await service.getSettings();
        const approval = await service.getApproval();
        const summary = await service.getSummary();

        return createJsonResponse({
          success: true,
          currentPhase: {
            code: summary.currentPhase,
            name: PHASE_NAMES_EN[summary.currentPhase],
          },
          canAdvance: gateResult.canAdvance,
          gates: gateResult.gates,
          blockingReason: gateResult.blockingReason,
          hint: gateResult.hint,
          settings: {
            autonomous_mode: settings.autonomous_mode,
            require_plan: settings.require_plan,
            require_approval: settings.require_approval,
          },
          approval: approval ? {
            plan_created: approval.plan_created,
            plan_approved: approval.plan_approved,
            approved_by: approval.approved_by,
            approved_at: approval.approved_at,
          } : null,
        });
      }

      case 'approvePlan': {
        if (!(await service.hasWorkflow())) {
          return createJsonResponse({
            success: false,
            error: 'No workflow found. Initialize a workflow first.',
            suggestion: 'Use workflow-init({ name: "feature-name" }) to start.',
          });
        }

        const currentApproval = await service.getApproval();
        if (!currentApproval?.plan_created) {
          return createJsonResponse({
            success: false,
            error: 'No plan is linked to approve. Link a plan first using plan({ action: "link" }).',
            hint: 'Use context({ action: "scaffoldPlan" }) to create a plan, then plan({ action: "link" }) to link it.'
          });
        }

        const approval = await service.approvePlan(
          params.approver || 'reviewer',
          params.notes
        );

        if (params.planSlug) {
          const planLinker = createPlanLinker(repoPath);
          const plans = await planLinker.getLinkedPlans();
          const planRef = plans.active.find(p => p.slug === params.planSlug);
          if (planRef) {
            planRef.approval_status = 'approved';
            planRef.approved_at = approval.approved_at;
            planRef.approved_by = approval.approved_by as string;
          }
        }

        const gateResult = await service.checkGates();

        return createJsonResponse({
          success: true,
          message: 'Plan approved successfully',
          approval: {
            plan_approved: approval.plan_approved,
            approved_by: approval.approved_by,
            approved_at: approval.approved_at,
            approval_notes: approval.approval_notes,
          },
          canAdvanceToExecution: gateResult.gates.approval_required.passed,
        });
      }

      case 'setAutonomous': {
        if (!(await service.hasWorkflow())) {
          return createJsonResponse({
            success: false,
            error: 'No workflow found. Initialize a workflow first.',
            suggestion: 'Use workflow-init({ name: "feature-name" }) to start.',
          });
        }

        const settings = await service.setAutonomousMode(params.enabled!);

        return createJsonResponse({
          success: true,
          message: `Autonomous mode ${params.enabled ? 'enabled' : 'disabled'}${params.reason ? `: ${params.reason}` : ''}`,
          settings: {
            autonomous_mode: settings.autonomous_mode,
            require_plan: settings.require_plan,
            require_approval: settings.require_approval,
          },
          effect: params.enabled
            ? 'All workflow gates are now bypassed. Use workflow-advance() freely.'
            : 'Workflow gates are now enforced based on settings.',
        });
      }

      default:
        return createErrorResponse(`Unknown workflow manage action: ${params.action}`);
    }
  } catch (error) {
    return createErrorResponse(error);
  }
}
