import * as fs from 'fs-extra';
import * as path from 'path';
import { RepoStructure, AgentPrompt } from '../types';
import { FileMapper } from '../utils/fileMapper';
import { BaseLLMClient } from '../services/baseLLMClient';
import chalk from 'chalk';

export class AgentGenerator {
  private agentTypes = [
    'code-reviewer',
    'bug-fixer',
    'feature-developer',
    'refactoring-specialist',
    'test-writer',
    'documentation-writer',
    'performance-optimizer',
    'security-auditor'
  ];

  constructor(
    private fileMapper: FileMapper,
    private llmClient: BaseLLMClient
  ) {}

  async generateAgentPrompts(
    repoStructure: RepoStructure,
    outputDir: string,
    verbose: boolean = false
  ): Promise<void> {
    const agentsDir = path.join(outputDir, 'agents');
    await fs.ensureDir(agentsDir);

    if (verbose) {
      console.log(chalk.blue(`ü§ñ Generating agent prompts in: ${agentsDir}`));
    }

    const repoContext = this.createRepoContext(repoStructure);
    const fileContext = await this.createFileContext(repoStructure);

    for (const agentType of this.agentTypes) {
      try {
        if (verbose) {
          console.log(chalk.yellow(`üîß Generating ${agentType} agent...`));
        }

        const agentPrompt = await this.generateAgentPrompt(
          agentType,
          repoContext,
          fileContext,
          repoStructure
        );

        const agentPath = path.join(agentsDir, `${agentType}.md`);
        await fs.writeFile(agentPath, agentPrompt);

        if (verbose) {
          console.log(chalk.green(`‚úÖ Agent prompt generated: ${agentType}.md`));
        }
      } catch (error) {
        if (verbose) {
          console.log(chalk.red(`‚ùå Error generating ${agentType}: ${error}`));
        }
      }
    }

    // Generate master agent index
    await this.generateAgentIndex(agentsDir, verbose);
  }

  private async generateAgentPrompt(
    agentType: string,
    repoContext: string,
    fileContext: string,
    repoStructure: RepoStructure
  ): Promise<string> {
    const structureOverview = this.createStructureOverview(repoStructure);
    
    const agentPrompt = await this.llmClient.generateAgentPrompt(
      structureOverview,
      fileContext,
      agentType
    );

    return this.formatAgentPrompt(agentType, agentPrompt, repoContext);
  }

  private formatAgentPrompt(
    agentType: string,
    generatedPrompt: string,
    repoContext: string
  ): string {
    const title = agentType.split('-').map(word => 
      word.charAt(0).toUpperCase() + word.slice(1)
    ).join(' ');

    return `# ${title} Agent

## Role Description
You are a specialized ${title} agent for this codebase. Your primary function is to assist with ${agentType.replace('-', ' ')} tasks while maintaining deep understanding of the project structure and conventions.

## Repository Context
${repoContext}

## Agent-Specific Prompt
${generatedPrompt}

## Key Responsibilities
${this.getAgentResponsibilities(agentType)}

## Best Practices
${this.getAgentBestPractices(agentType)}

## Common Commands and Patterns
${this.getAgentCommands(agentType)}

---
*Generated by AI Coders Context*
*Agent Type: ${agentType}*
*Generated on: ${new Date().toISOString()}*
`;
  }

  private getAgentResponsibilities(agentType: string): string {
    const responsibilities: { [key: string]: string[] } = {
      'code-reviewer': [
        'Review code changes for quality, style, and best practices',
        'Identify potential bugs and security issues',
        'Ensure code follows project conventions',
        'Provide constructive feedback and suggestions'
      ],
      'bug-fixer': [
        'Analyze bug reports and error messages',
        'Identify root causes of issues',
        'Implement targeted fixes with minimal side effects',
        'Test fixes thoroughly before deployment'
      ],
      'feature-developer': [
        'Implement new features according to specifications',
        'Design clean, maintainable code architecture',
        'Integrate features with existing codebase',
        'Write comprehensive tests for new functionality'
      ],
      'refactoring-specialist': [
        'Identify code smells and improvement opportunities',
        'Refactor code while maintaining functionality',
        'Improve code organization and structure',
        'Optimize performance where applicable'
      ],
      'test-writer': [
        'Write comprehensive unit and integration tests',
        'Ensure good test coverage across the codebase',
        'Create test utilities and fixtures',
        'Maintain and update existing tests'
      ],
      'documentation-writer': [
        'Create clear, comprehensive documentation',
        'Update existing documentation as code changes',
        'Write helpful code comments and examples',
        'Maintain README and API documentation'
      ],
      'performance-optimizer': [
        'Identify performance bottlenecks',
        'Optimize code for speed and efficiency',
        'Implement caching strategies',
        'Monitor and improve resource usage'
      ],
      'security-auditor': [
        'Identify security vulnerabilities',
        'Implement security best practices',
        'Review dependencies for security issues',
        'Ensure data protection and privacy compliance'
      ]
    };

    return responsibilities[agentType]?.map(r => `- ${r}`).join('\n') || 
           '- Perform specialized tasks for this agent type';
  }

  private getAgentBestPractices(agentType: string): string {
    const practices: { [key: string]: string[] } = {
      'code-reviewer': [
        'Focus on maintainability and readability',
        'Consider the broader impact of changes',
        'Be constructive and specific in feedback'
      ],
      'bug-fixer': [
        'Reproduce the bug before fixing',
        'Write tests to prevent regression',
        'Document the fix for future reference'
      ],
      'feature-developer': [
        'Follow existing patterns and conventions',
        'Consider edge cases and error handling',
        'Write tests alongside implementation'
      ],
      'refactoring-specialist': [
        'Make small, incremental changes',
        'Ensure tests pass after each refactor',
        'Preserve existing functionality exactly'
      ],
      'test-writer': [
        'Write tests that are clear and maintainable',
        'Test both happy path and edge cases',
        'Use descriptive test names'
      ],
      'documentation-writer': [
        'Keep documentation up-to-date with code',
        'Write from the user\'s perspective',
        'Include practical examples'
      ],
      'performance-optimizer': [
        'Measure before optimizing',
        'Focus on actual bottlenecks',
        'Don\'t sacrifice readability unnecessarily'
      ],
      'security-auditor': [
        'Follow security best practices',
        'Stay updated on common vulnerabilities',
        'Consider the principle of least privilege'
      ]
    };

    return practices[agentType]?.map(p => `- ${p}`).join('\n') || 
           '- Follow general best practices for software development';
  }

  private getAgentCommands(agentType: string): string {
    return `Common patterns and commands for ${agentType} tasks:

\`\`\`bash
# Add relevant commands here based on the codebase
npm test          # Run tests
npm run lint      # Check code style
npm run build     # Build the project
\`\`\`

Refer to the project's package.json or documentation for specific commands.`;
  }

  private createRepoContext(repoStructure: RepoStructure): string {
    const { files, totalFiles, totalSize } = repoStructure;
    
    const extensions = new Map<string, number>();
    files.forEach(file => {
      const ext = file.extension || 'no-extension';
      extensions.set(ext, (extensions.get(ext) || 0) + 1);
    });

    const topExtensions = Array.from(extensions.entries())
      .sort((a, b) => b[1] - a[1])
      .slice(0, 5);

    return `**Project Statistics:**
- Total Files: ${totalFiles}
- Total Size: ${this.formatBytes(totalSize)}
- Primary Languages: ${topExtensions.map(([ext, count]) => `${ext} (${count})`).join(', ')}

**Key Project Files:**
${files
  .filter(f => ['package.json', 'README.md', 'tsconfig.json'].includes(path.basename(f.path)))
  .map(f => `- ${f.relativePath}`)
  .join('\n')}`;
  }

  private async createFileContext(repoStructure: RepoStructure): Promise<string> {
    const importantFiles = repoStructure.files
      .filter(f => this.isImportantFile(f.relativePath))
      .slice(0, 10);

    let context = '**Important Files Context:**\n\n';
    
    for (const file of importantFiles) {
      try {
        const content = await this.fileMapper.readFileContent(file.path);
        const preview = content.substring(0, 500);
        context += `**${file.relativePath}:**\n\`\`\`\n${preview}${content.length > 500 ? '...' : ''}\n\`\`\`\n\n`;
      } catch (error) {
        context += `**${file.relativePath}:** (Error reading file)\n\n`;
      }
    }

    return context;
  }

  private createStructureOverview(repoStructure: RepoStructure): string {
    const directories = [...new Set(
      repoStructure.files.map(f => path.dirname(f.relativePath))
    )].filter(dir => dir !== '.').slice(0, 20);

    return `Repository Structure Overview:

Directories:
${directories.map(dir => `- ${dir}`).join('\n')}

File Types:
${this.getFileTypeDistribution(repoStructure)}

Total Files: ${repoStructure.totalFiles}
`;
  }

  private getFileTypeDistribution(repoStructure: RepoStructure): string {
    const extensions = new Map<string, number>();
    repoStructure.files.forEach(file => {
      const ext = file.extension || 'no-extension';
      extensions.set(ext, (extensions.get(ext) || 0) + 1);
    });

    return Array.from(extensions.entries())
      .sort((a, b) => b[1] - a[1])
      .slice(0, 10)
      .map(([ext, count]) => `- ${ext}: ${count} files`)
      .join('\n');
  }

  private isImportantFile(filePath: string): boolean {
    const importantFiles = [
      'package.json', 'tsconfig.json', 'webpack.config.js', 
      'next.config.js', 'tailwind.config.js', 'README.md',
      '.gitignore', 'Dockerfile', 'docker-compose.yml'
    ];
    
    const fileName = path.basename(filePath);
    return importantFiles.includes(fileName) || 
           filePath.includes('config') || 
           filePath.includes('index');
  }

  private async generateAgentIndex(agentsDir: string, verbose: boolean): Promise<void> {
    const indexContent = `# AI Agents Index

This directory contains specialized AI agent prompts designed for this codebase.

## Available Agents

${this.agentTypes.map(type => {
  const title = type.split('-').map(word => 
    word.charAt(0).toUpperCase() + word.slice(1)
  ).join(' ');
  return `### [${title}](${type}.md)
- **File:** \`${type}.md\`
- **Purpose:** Specialized ${title.toLowerCase()} tasks
`;
}).join('\n')}

## Usage

Each agent prompt is designed to provide context-aware assistance for specific development tasks. Use these prompts with your preferred AI assistant to get specialized help with your codebase.

## How to Use

1. Choose the appropriate agent for your task
2. Copy the agent prompt from the corresponding .md file
3. Provide the prompt to your AI assistant along with your specific question or task
4. The agent will provide context-aware assistance based on your codebase structure

---
*Generated by AI Coders Context*
*Generated on: ${new Date().toISOString()}*
`;

    const indexPath = path.join(agentsDir, 'README.md');
    await fs.writeFile(indexPath, indexContent);

    if (verbose) {
      console.log(chalk.green('‚úÖ Agent index generated: README.md'));
    }
  }

  private formatBytes(bytes: number): string {
    if (bytes === 0) return '0 Bytes';
    const k = 1024;
    const sizes = ['Bytes', 'KB', 'MB', 'GB'];
    const i = Math.floor(Math.log(bytes) / Math.log(k));
    return parseFloat((bytes / Math.pow(k, i)).toFixed(2)) + ' ' + sizes[i];
  }
}