import { RepoStructure } from '../../types';
import { BaseLLMClient } from '../../services/baseLLMClient';
import { ModuleGroup } from '../moduleGrouper';
import { ProjectAnalyzer } from '../projectAnalyzer';
import { DocumentationUtils } from './documentationUtils';

export class DocumentationTemplates {
  constructor(private llmClient: BaseLLMClient) {}

  createMainIndex(repoStructure: RepoStructure, moduleGroups: ModuleGroup[]): string {
    return `# Documentation Index

Welcome to the project documentation. This guide is organized into the following sections:

## ðŸ“š Documentation Structure

### [Overview](./overview.md)
High-level project overview, statistics, and key components.

### [Architecture](./architecture.md)
System architecture, design patterns, and technical decisions.

### [Modules](./modules/)
Detailed documentation for each module/component:
${moduleGroups.map(group => 
  `- [${group.name}](./modules/${DocumentationUtils.slugify(group.name)}.md) - ${group.description}`
).join('\n')}

### [API Reference](./api-reference.md)
Complete API documentation for all public interfaces.

### [Configuration](./configuration.md)
Configuration options, environment variables, and setup guides.

## ðŸš€ Quick Links

- [Getting Started](#getting-started)
- [Project Structure](./overview.md#project-structure)
- [Key Components](./architecture.md#key-components)
- [Contributing Guidelines](../CONTRIBUTING.md)

---
*Generated by AI Coders Context*
*Last updated: ${new Date().toISOString()}*
`;
  }

  createEnhancedProjectOverview(repoStructure: RepoStructure): string {
    const { files, directories, totalFiles, totalSize } = repoStructure;
    
    const extensions = new Map<string, number>();
    files.forEach(file => {
      const ext = file.extension || 'no-extension';
      extensions.set(ext, (extensions.get(ext) || 0) + 1);
    });

    const topExtensions = Array.from(extensions.entries())
      .sort((a, b) => b[1] - a[1])
      .slice(0, 10);

    const projectType = ProjectAnalyzer.identifyProjectType(repoStructure);
    const techStack = ProjectAnalyzer.identifyTechStack(repoStructure);

    return `# Project Overview

## Project Information
- **Type**: ${projectType}
- **Technology Stack**: ${techStack.join(', ')}
- **Total Files**: ${totalFiles}
- **Total Size**: ${DocumentationUtils.formatBytes(totalSize)}

## Project Structure

### Directory Overview
\`\`\`
${ProjectAnalyzer.createSimplifiedTree(repoStructure)}
\`\`\`

### File Distribution
${topExtensions.map(([ext, count]) => `- **${ext}**: ${count} files (${((count/totalFiles)*100).toFixed(1)}%)`).join('\n')}

## Key Files
${ProjectAnalyzer.identifyKeyFiles(repoStructure).map(f => `- \`${f.relativePath}\` - ${f.description}`).join('\n')}

## Development Setup

Refer to the [Configuration Guide](./configuration.md) for detailed setup instructions.

---
*Generated by AI Coders Context*
`;
  }

  createArchitectureDocumentation(repoStructure: RepoStructure, moduleGroups: ModuleGroup[]): string {
    const techStack = ProjectAnalyzer.identifyTechStack(repoStructure);

    return `# Architecture Documentation

## System Overview

This document describes the high-level architecture of the project.

## Technology Stack

${techStack.map(tech => `- **${tech}**`).join('\n')}

## Component Architecture

### Core Modules

${moduleGroups.map(module => `#### ${module.name}
- **Purpose**: ${module.description}
- **Files**: ${module.files.length}
- **Key Responsibilities**: [To be analyzed]
`).join('\n')}

## Design Patterns

Based on the codebase structure, the following patterns are identified:
- Command Pattern (CLI structure)
- Service Layer Pattern (services directory)
- Factory Pattern (generators)

## Data Flow

1. **Input Processing**: Command-line arguments are parsed
2. **File Analysis**: Repository structure is mapped
3. **Content Generation**: LLM-based documentation generation
4. **Output Generation**: Structured documentation output

## Dependencies

Analyze package.json for detailed dependency information.

---
*Generated by AI Coders Context*
`;
  }

  createAPIReference(repoStructure: RepoStructure, moduleGroups: ModuleGroup[]): string {
    const apiFiles = repoStructure.files.filter(f => 
      f.relativePath.includes('types') || 
      f.relativePath.includes('index') ||
      f.relativePath.endsWith('.ts')
    );

    return `# API Reference

## Overview

This document provides a complete reference for all public APIs in the project.

## Core APIs

### CLI Commands

#### \`generate\`
Generate documentation and agent prompts for a repository.

**Usage:**
\`\`\`bash
ai-context generate <repo-path> [options]
\`\`\`

**Options:**
- \`-o, --output <dir>\`: Output directory
- \`-k, --api-key <key>\`: OpenRouter API key
- \`-m, --model <model>\`: LLM model to use
- \`--exclude <patterns...>\`: Patterns to exclude
- \`--include <patterns...>\`: Patterns to include

#### \`analyze\`
Analyze repository structure without generating content.

**Usage:**
\`\`\`bash
ai-context analyze <repo-path> [options]
\`\`\`

## Module APIs

${moduleGroups.map(module => 
  `### ${module.name}\nSee [${module.name} Module Documentation](./modules/${DocumentationUtils.slugify(module.name)}.md)`
).join('\n\n')}

## Type Definitions

See the types module for detailed interface definitions.

---
*Generated by AI Coders Context*
`;
  }

  createConfigurationGuide(repoStructure: RepoStructure): string {
    const configFiles = repoStructure.files.filter(f => 
      f.relativePath.includes('config') ||
      f.relativePath.includes('.json') ||
      f.relativePath.includes('.env')
    );

    return `# Configuration Guide

## Environment Variables

### Required Variables

- \`OPENROUTER_API_KEY\`: Your OpenRouter API key for LLM access

### Optional Variables

- \`OPENROUTER_MODEL\`: Override default model (default: \`google/gemini-2.5-flash-preview-05-20\`)
- \`OPENROUTER_BASE_URL\`: Custom API endpoint (rarely needed)

## Configuration Files

${configFiles.map(f => `### ${f.relativePath}
Configuration file for ${DocumentationUtils.getConfigDescription(f.relativePath)}`).join('\n\n')}

## Setup Instructions

1. **Clone the repository**
   \`\`\`bash
   git clone https://github.com/vinilana/ai-coders-context.git
   cd ai-coders-context
   \`\`\`

2. **Install dependencies**
   \`\`\`bash
   npm install
   \`\`\`

3. **Configure environment**
   \`\`\`bash
   cp .env.example .env
   # Edit .env with your API key
   \`\`\`

4. **Build the project**
   \`\`\`bash
   npm run build
   \`\`\`

## Advanced Configuration

### Custom Model Selection

You can use any model available on OpenRouter:
- \`anthropic/claude-3-haiku\` - Fast and efficient
- \`anthropic/claude-3-sonnet\` - Balanced performance
- \`openai/gpt-4\` - High quality output
- \`google/gemini-2.5-flash-preview-05-20\` - Google's latest model

### Output Customization

Control what gets generated:
- \`--docs-only\`: Generate only documentation
- \`--agents-only\`: Generate only agent prompts
- \`--exclude\`: Exclude specific file patterns
- \`--include\`: Include only specific patterns

---
*Generated by AI Coders Context*
`;
  }

  async createDevelopmentGuide(repoStructure: RepoStructure, moduleGroups: ModuleGroup[]): Promise<string> {
    const configFiles = ProjectAnalyzer.getConfigurationFiles(repoStructure);
    const packageInfo = ProjectAnalyzer.getPackageInfo(repoStructure);

    const context = `Repository: ${repoStructure.rootPath}
Total Files: ${repoStructure.totalFiles}
Modules: ${moduleGroups.map(m => m.name).join(', ')}
Configuration Files: ${configFiles.map(f => f.relativePath.split('/').pop()).join(', ')}
Package Info: ${JSON.stringify(packageInfo, null, 2)}

Module Structure:
${moduleGroups.map(m => `- ${m.name}: ${m.description} (${m.files.length} files)`).join('\n')}`;

    return await this.llmClient.generateText(
      `Create a comprehensive development guide for this project. Include:

1. Getting Started (setup instructions)
2. Development Environment Requirements
3. Project Structure Overview
4. Development Workflow
5. Code Style and Standards
6. Testing Guidelines
7. Debugging Tips
8. Build Process
9. Contributing Guidelines

Format as clean Markdown with proper headings and code blocks.`,
      context
    );
  }

  async createDeploymentGuide(repoStructure: RepoStructure): Promise<string> {
    const packageInfo = ProjectAnalyzer.getPackageInfo(repoStructure);
    const configFiles = ProjectAnalyzer.getConfigurationFiles(repoStructure);
    const hasDockerfile = repoStructure.files.some(f => f.relativePath.toLowerCase().includes('dockerfile'));
    const hasKubernetes = repoStructure.files.some(f => f.relativePath.includes('k8s') || f.relativePath.includes('kubernetes'));

    const context = `Repository: ${repoStructure.rootPath}
Package Info: ${JSON.stringify(packageInfo, null, 2)}
Configuration Files: ${configFiles.map(f => f.relativePath.split('/').pop()).join(', ')}
Has Dockerfile: ${hasDockerfile}
Has Kubernetes: ${hasKubernetes}
Project Type: ${ProjectAnalyzer.detectProjectType(repoStructure)}`;

    return await this.llmClient.generateText(
      `Create a comprehensive deployment guide for this project. Include:

1. Prerequisites and Dependencies
2. Environment Configuration
3. Build Process for Production
4. Deployment Options (based on project type)
5. Environment Variables and Secrets
6. Database Setup (if applicable)
7. Monitoring and Health Checks
8. Rollback Procedures
9. Security Considerations
10. Performance Optimization

Adapt the guide based on the project type and available configuration files.
Format as clean Markdown with proper headings and code blocks.`,
      context
    );
  }

  async createTroubleshootingGuide(repoStructure: RepoStructure, moduleGroups: ModuleGroup[]): Promise<string> {
    const packageInfo = ProjectAnalyzer.getPackageInfo(repoStructure);
    const projectType = ProjectAnalyzer.detectProjectType(repoStructure);

    const context = `Repository: ${repoStructure.rootPath}
Project Type: ${projectType}
Package Info: ${JSON.stringify(packageInfo, null, 2)}
Modules: ${moduleGroups.map(m => `${m.name} (${m.files.length} files)`).join(', ')}`;

    return await this.llmClient.generateText(
      `Create a comprehensive troubleshooting guide for this ${projectType} project. Include:

1. Common Issues and Solutions
2. Development Environment Problems
3. Build and Compilation Errors
4. Runtime Errors and Debugging
5. Performance Issues
6. Dependency Problems
7. Configuration Issues
8. Testing Problems
9. Deployment Issues
10. Debugging Tools and Techniques
11. Log Analysis
12. FAQ Section

Focus on practical solutions and include code examples where helpful.
Format as clean Markdown with proper headings and code blocks.`,
      context
    );
  }
} 