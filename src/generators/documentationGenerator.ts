import * as fs from 'fs-extra';
import * as path from 'path';
import { FileInfo, RepoStructure } from '../types';
import { FileMapper } from '../utils/fileMapper';
import { BaseLLMClient } from '../services/baseLLMClient';
import chalk from 'chalk';

interface ModuleGroup {
  name: string;
  description: string;
  files: FileInfo[];
}

export class DocumentationGenerator {
  constructor(
    private fileMapper: FileMapper,
    private llmClient: BaseLLMClient
  ) {}

  async generateDocumentation(
    repoStructure: RepoStructure,
    outputDir: string,
    verbose: boolean = false
  ): Promise<void> {
    const docsDir = path.join(outputDir, 'docs');
    await fs.ensureDir(docsDir);

    if (verbose) {
      console.log(chalk.blue(`üìö Generating documentation in: ${docsDir}`));
    }

    // Generate main documentation index
    await this.generateMainIndex(repoStructure, docsDir, verbose);

    // Generate overview documentation
    await this.generateOverview(repoStructure, docsDir, verbose);

    // Generate architecture documentation
    await this.generateArchitectureDoc(repoStructure, docsDir, verbose);

    // Generate module-based documentation
    await this.generateModuleDocumentation(repoStructure, docsDir, verbose);

    // Generate API reference
    await this.generateAPIReference(repoStructure, docsDir, verbose);

    // Generate configuration guide
    await this.generateConfigurationGuide(repoStructure, docsDir, verbose);

    // Generate development guide
    await this.generateDevelopmentGuide(repoStructure, docsDir, verbose);

    // Generate deployment guide
    await this.generateDeploymentGuide(repoStructure, docsDir, verbose);

    // Generate troubleshooting guide
    await this.generateTroubleshootingGuide(repoStructure, docsDir, verbose);
  }

  private async generateMainIndex(
    repoStructure: RepoStructure,
    docsDir: string,
    verbose: boolean
  ): Promise<void> {
    if (verbose) {
      console.log(chalk.yellow('üìù Generating documentation index...'));
    }

    const indexContent = `# Documentation Index

Welcome to the project documentation. This guide is organized into the following sections:

## üìö Documentation Structure

### [Overview](./overview.md)
High-level project overview, statistics, and key components.

### [Architecture](./architecture.md)
System architecture, design patterns, and technical decisions.

### [Modules](./modules/)
Detailed documentation for each module/component:
${this.getModuleGroups(repoStructure).map(group => 
  `- [${group.name}](./modules/${this.slugify(group.name)}.md) - ${group.description}`
).join('\n')}

### [API Reference](./api-reference.md)
Complete API documentation for all public interfaces.

### [Configuration](./configuration.md)
Configuration options, environment variables, and setup guides.

## üöÄ Quick Links

- [Getting Started](#getting-started)
- [Project Structure](./overview.md#project-structure)
- [Key Components](./architecture.md#key-components)
- [Contributing Guidelines](../CONTRIBUTING.md)

---
*Generated by AI Coders Context*
*Last updated: ${new Date().toISOString()}*
`;

    const indexPath = path.join(docsDir, 'README.md');
    await fs.writeFile(indexPath, indexContent);

    if (verbose) {
      console.log(chalk.green(`‚úÖ Documentation index saved: ${indexPath}`));
    }
  }

  private async generateOverview(
    repoStructure: RepoStructure,
    docsDir: string,
    verbose: boolean
  ): Promise<void> {
    if (verbose) {
      console.log(chalk.yellow('üìù Generating project overview...'));
    }

    const overview = await this.createEnhancedProjectOverview(repoStructure);
    const overviewPath = path.join(docsDir, 'overview.md');
    await fs.writeFile(overviewPath, overview);

    if (verbose) {
      console.log(chalk.green(`‚úÖ Project overview saved: ${overviewPath}`));
    }
  }

  private async generateArchitectureDoc(
    repoStructure: RepoStructure,
    docsDir: string,
    verbose: boolean
  ): Promise<void> {
    if (verbose) {
      console.log(chalk.yellow('üèóÔ∏è Generating architecture documentation...'));
    }

    const architecture = await this.createArchitectureDocumentation(repoStructure);
    const archPath = path.join(docsDir, 'architecture.md');
    await fs.writeFile(archPath, architecture);

    if (verbose) {
      console.log(chalk.green(`‚úÖ Architecture documentation saved: ${archPath}`));
    }
  }

  private async generateModuleDocumentation(
    repoStructure: RepoStructure,
    docsDir: string,
    verbose: boolean
  ): Promise<void> {
    const modulesDir = path.join(docsDir, 'modules');
    await fs.ensureDir(modulesDir);

    const moduleGroups = this.getModuleGroups(repoStructure);

    if (verbose) {
      console.log(chalk.yellow(`üì¶ Generating documentation for ${moduleGroups.length} modules...`));
    }

    for (const module of moduleGroups) {
      try {
        const moduleDoc = await this.createModuleDocumentation(module, repoStructure);
        const modulePath = path.join(modulesDir, `${this.slugify(module.name)}.md`);
        await fs.writeFile(modulePath, moduleDoc);

        if (verbose) {
          console.log(chalk.green(`‚úÖ Module documentation generated: ${module.name}`));
        }
      } catch (error) {
        if (verbose) {
          console.log(chalk.red(`‚ùå Error documenting module ${module.name}: ${error}`));
        }
      }
    }
  }

  private async generateAPIReference(
    repoStructure: RepoStructure,
    docsDir: string,
    verbose: boolean
  ): Promise<void> {
    if (verbose) {
      console.log(chalk.yellow('üîå Generating API reference...'));
    }

    const apiRef = await this.createAPIReference(repoStructure);
    const apiPath = path.join(docsDir, 'api-reference.md');
    await fs.writeFile(apiPath, apiRef);

    if (verbose) {
      console.log(chalk.green(`‚úÖ API reference saved: ${apiPath}`));
    }
  }

  private async generateConfigurationGuide(
    repoStructure: RepoStructure,
    docsDir: string,
    verbose: boolean
  ): Promise<void> {
    if (verbose) {
      console.log(chalk.yellow('‚öôÔ∏è Generating configuration guide...'));
    }

    const configGuide = await this.createConfigurationGuide(repoStructure);
    const configPath = path.join(docsDir, 'configuration.md');
    await fs.writeFile(configPath, configGuide);

    if (verbose) {
      console.log(chalk.green(`‚úÖ Configuration guide saved: ${configPath}`));
    }
  }

  private getModuleGroups(repoStructure: RepoStructure): ModuleGroup[] {
    const groups: Map<string, FileInfo[]> = new Map();
    
    // Group files by their top-level directory or logical module
    repoStructure.files.forEach(file => {
      if (!this.fileMapper.isTextFile(file.path)) return;
      
      const parts = file.relativePath.split(path.sep);
      let groupName = 'Root Files';
      
      if (parts.length > 1) {
        groupName = parts[0];
        // Special handling for src files
        if (groupName === 'src' && parts.length > 2) {
          groupName = `${parts[1]}`;
        }
      }
      
      if (!groups.has(groupName)) {
        groups.set(groupName, []);
      }
      groups.get(groupName)!.push(file);
    });

    // Convert to ModuleGroup array with descriptions
    return Array.from(groups.entries()).map(([name, files]) => ({
      name: this.formatModuleName(name),
      description: this.getModuleDescription(name, files),
      files
    })).sort((a, b) => a.name.localeCompare(b.name));
  }

  private formatModuleName(name: string): string {
    return name
      .split(/[-_]/)
      .map(word => word.charAt(0).toUpperCase() + word.slice(1))
      .join(' ');
  }

  private getModuleDescription(name: string, files: FileInfo[]): string {
    const descriptions: { [key: string]: string } = {
      'generators': 'Code generation utilities for documentation and agents',
      'services': 'External service integrations and API clients',
      'utils': 'Utility functions and helper modules',
      'types': 'TypeScript type definitions and interfaces',
      'Root Files': 'Main configuration and entry point files'
    };

    return descriptions[name] || `${this.formatModuleName(name)} module with ${files.length} files`;
  }

  private async createModuleDocumentation(
    module: ModuleGroup,
    repoStructure: RepoStructure
  ): Promise<string> {
    const fileContents: string[] = [];
    
    for (const file of module.files.slice(0, 10)) { // Limit to prevent too large requests
      const content = await this.fileMapper.readFileContent(file.path);
      fileContents.push(`File: ${file.relativePath}\n${content.substring(0, 1000)}...`);
    }

    const moduleContext = `Module: ${module.name}
Description: ${module.description}
Files: ${module.files.map(f => f.relativePath).join(', ')}

Sample content from module files:
${fileContents.join('\n\n---\n\n')}`;

    const documentation = await this.llmClient.generateText(
      `Generate comprehensive documentation for this module. Include:
1. Module overview and purpose
2. Key components and their responsibilities
3. Public APIs and interfaces
4. Usage examples
5. Dependencies and relationships

Module context:
${moduleContext}`,
      'You are a technical documentation expert. Create clear, well-structured module documentation.'
    );

    return `# ${module.name}

${documentation}

## Files in this module

${module.files.map(file => `- \`${file.relativePath}\` - ${this.formatBytes(file.size)}`).join('\n')}

---
*Generated by AI Coders Context*
`;
  }

  private async createEnhancedProjectOverview(repoStructure: RepoStructure): Promise<string> {
    const { files, directories, totalFiles, totalSize } = repoStructure;
    
    const extensions = new Map<string, number>();
    files.forEach(file => {
      const ext = file.extension || 'no-extension';
      extensions.set(ext, (extensions.get(ext) || 0) + 1);
    });

    const topExtensions = Array.from(extensions.entries())
      .sort((a, b) => b[1] - a[1])
      .slice(0, 10);

    // Try to identify project type
    const projectType = this.identifyProjectType(repoStructure);
    const techStack = this.identifyTechStack(repoStructure);

    return `# Project Overview

## Project Information
- **Type**: ${projectType}
- **Technology Stack**: ${techStack.join(', ')}
- **Total Files**: ${totalFiles}
- **Total Size**: ${this.formatBytes(totalSize)}

## Project Structure

### Directory Overview
\`\`\`
${this.createSimplifiedTree(repoStructure)}
\`\`\`

### File Distribution
${topExtensions.map(([ext, count]) => `- **${ext}**: ${count} files (${((count/totalFiles)*100).toFixed(1)}%)`).join('\n')}

## Key Files
${this.identifyKeyFiles(repoStructure).map(f => `- \`${f.relativePath}\` - ${f.description}`).join('\n')}

## Development Setup

Refer to the [Configuration Guide](./configuration.md) for detailed setup instructions.

---
*Generated by AI Coders Context*
`;
  }

  private async createArchitectureDocumentation(repoStructure: RepoStructure): Promise<string> {
    const modules = this.getModuleGroups(repoStructure);
    const techStack = this.identifyTechStack(repoStructure);

    return `# Architecture Documentation

## System Overview

This document describes the high-level architecture of the project.

## Technology Stack

${techStack.map(tech => `- **${tech}**`).join('\n')}

## Component Architecture

### Core Modules

${modules.map(module => `#### ${module.name}
- **Purpose**: ${module.description}
- **Files**: ${module.files.length}
- **Key Responsibilities**: [To be analyzed]
`).join('\n')}

## Design Patterns

Based on the codebase structure, the following patterns are identified:
- Command Pattern (CLI structure)
- Service Layer Pattern (services directory)
- Factory Pattern (generators)

## Data Flow

1. **Input Processing**: Command-line arguments are parsed
2. **File Analysis**: Repository structure is mapped
3. **Content Generation**: LLM-based documentation generation
4. **Output Generation**: Structured documentation output

## Dependencies

Analyze package.json for detailed dependency information.

---
*Generated by AI Coders Context*
`;
  }

  private async createAPIReference(repoStructure: RepoStructure): Promise<string> {
    const apiFiles = repoStructure.files.filter(f => 
      f.relativePath.includes('types') || 
      f.relativePath.includes('index') ||
      f.relativePath.endsWith('.ts')
    );

    return `# API Reference

## Overview

This document provides a complete reference for all public APIs in the project.

## Core APIs

### CLI Commands

#### \`generate\`
Generate documentation and agent prompts for a repository.

**Usage:**
\`\`\`bash
ai-context generate <repo-path> [options]
\`\`\`

**Options:**
- \`-o, --output <dir>\`: Output directory
- \`-k, --api-key <key>\`: OpenRouter API key
- \`-m, --model <model>\`: LLM model to use
- \`--exclude <patterns...>\`: Patterns to exclude
- \`--include <patterns...>\`: Patterns to include

#### \`analyze\`
Analyze repository structure without generating content.

**Usage:**
\`\`\`bash
ai-context analyze <repo-path> [options]
\`\`\`

## Module APIs

${this.getModuleGroups(repoStructure).map(module => 
  `### ${module.name}\nSee [${module.name} Module Documentation](./modules/${this.slugify(module.name)}.md)`
).join('\n\n')}

## Type Definitions

See the types module for detailed interface definitions.

---
*Generated by AI Coders Context*
`;
  }

  private async createConfigurationGuide(repoStructure: RepoStructure): Promise<string> {
    const configFiles = repoStructure.files.filter(f => 
      f.relativePath.includes('config') ||
      f.relativePath.includes('.json') ||
      f.relativePath.includes('.env')
    );

    return `# Configuration Guide

## Environment Variables

### Required Variables

- \`OPENROUTER_API_KEY\`: Your OpenRouter API key for LLM access

### Optional Variables

- \`OPENROUTER_MODEL\`: Override default model (default: \`google/gemini-2.5-flash-preview-05-20\`)
- \`OPENROUTER_BASE_URL\`: Custom API endpoint (rarely needed)

## Configuration Files

${configFiles.map(f => `### ${f.relativePath}
Configuration file for ${this.getConfigDescription(f.relativePath)}`).join('\n\n')}

## Setup Instructions

1. **Clone the repository**
   \`\`\`bash
   git clone https://github.com/vinilana/ai-coders-context.git
   cd ai-coders-context
   \`\`\`

2. **Install dependencies**
   \`\`\`bash
   npm install
   \`\`\`

3. **Configure environment**
   \`\`\`bash
   cp .env.example .env
   # Edit .env with your API key
   \`\`\`

4. **Build the project**
   \`\`\`bash
   npm run build
   \`\`\`

## Advanced Configuration

### Custom Model Selection

You can use any model available on OpenRouter:
- \`anthropic/claude-3-haiku\` - Fast and efficient
- \`anthropic/claude-3-sonnet\` - Balanced performance
- \`openai/gpt-4\` - High quality output
- \`google/gemini-2.5-flash-preview-05-20\` - Google's latest model

### Output Customization

Control what gets generated:
- \`--docs-only\`: Generate only documentation
- \`--agents-only\`: Generate only agent prompts
- \`--exclude\`: Exclude specific file patterns
- \`--include\`: Include only specific patterns

---
*Generated by AI Coders Context*
`;
  }

  private identifyProjectType(repoStructure: RepoStructure): string {
    const files = repoStructure.files.map(f => f.relativePath);
    
    if (files.some(f => f === 'package.json')) {
      if (files.some(f => f.includes('react') || f.includes('.jsx') || f.includes('.tsx'))) {
        return 'React Application';
      } else if (files.some(f => f.includes('angular.json'))) {
        return 'Angular Application';
      } else if (files.some(f => f.includes('vue'))) {
        return 'Vue Application';
      } else if (files.some(f => f.includes('next.config'))) {
        return 'Next.js Application';
      }
      return 'Node.js Project';
    } else if (files.some(f => f === 'requirements.txt' || f === 'setup.py')) {
      return 'Python Project';
    } else if (files.some(f => f === 'pom.xml')) {
      return 'Java Maven Project';
    } else if (files.some(f => f === 'build.gradle')) {
      return 'Java Gradle Project';
    }
    
    return 'General Software Project';
  }

  private identifyTechStack(repoStructure: RepoStructure): string[] {
    const stack: string[] = [];
    const files = repoStructure.files.map(f => f.relativePath);
    
    // Languages
    if (files.some(f => f.endsWith('.ts') || f.endsWith('.tsx'))) stack.push('TypeScript');
    if (files.some(f => f.endsWith('.js') || f.endsWith('.jsx'))) stack.push('JavaScript');
    if (files.some(f => f.endsWith('.py'))) stack.push('Python');
    if (files.some(f => f.endsWith('.java'))) stack.push('Java');
    
    // Frameworks
    if (files.some(f => f === 'package.json')) stack.push('Node.js');
    if (files.some(f => f.includes('react'))) stack.push('React');
    if (files.some(f => f.includes('vue'))) stack.push('Vue');
    if (files.some(f => f.includes('angular'))) stack.push('Angular');
    
    // Tools
    if (files.some(f => f === 'tsconfig.json')) stack.push('TypeScript Compiler');
    if (files.some(f => f === 'jest.config.js')) stack.push('Jest');
    if (files.some(f => f === 'webpack.config.js')) stack.push('Webpack');
    
    return [...new Set(stack)];
  }

  private identifyKeyFiles(repoStructure: RepoStructure): Array<{relativePath: string, description: string}> {
    const keyFiles: Array<{relativePath: string, description: string}> = [];
    
    repoStructure.files.forEach(file => {
      const basename = path.basename(file.path);
      const descriptions: { [key: string]: string } = {
        'package.json': 'Node.js project configuration and dependencies',
        'tsconfig.json': 'TypeScript compiler configuration',
        'README.md': 'Project documentation and setup guide',
        '.gitignore': 'Git ignore patterns',
        'LICENSE': 'Project license information',
        'index.ts': 'Main entry point',
        'index.js': 'Main entry point',
        '.env.example': 'Environment variable template'
      };
      
      if (descriptions[basename]) {
        keyFiles.push({
          relativePath: file.relativePath,
          description: descriptions[basename]
        });
      }
    });
    
    return keyFiles;
  }

  private createSimplifiedTree(repoStructure: RepoStructure): string {
    const tree: { [key: string]: Set<string> } = {};
    
    // Build directory structure
    repoStructure.files.forEach(file => {
      const parts = file.relativePath.split(path.sep);
      if (parts.length > 1) {
        const dir = parts[0];
        if (!tree[dir]) tree[dir] = new Set();
        if (parts.length === 2) {
          tree[dir].add(parts[1]);
        }
      }
    });
    
    // Create tree visualization
    let result = '';
    const dirs = Object.keys(tree).sort();
    
    dirs.forEach((dir, index) => {
      const isLast = index === dirs.length - 1;
      result += `${isLast ? '‚îî‚îÄ‚îÄ ' : '‚îú‚îÄ‚îÄ '}${dir}/\n`;
      
      const files = Array.from(tree[dir]).slice(0, 3);
      files.forEach((file, fIndex) => {
        const isLastFile = fIndex === files.length - 1 && tree[dir].size <= 3;
        result += `${isLast ? '    ' : '‚îÇ   '}${isLastFile ? '‚îî‚îÄ‚îÄ ' : '‚îú‚îÄ‚îÄ '}${file}\n`;
      });
      
      if (tree[dir].size > 3) {
        result += `${isLast ? '    ' : '‚îÇ   '}‚îî‚îÄ‚îÄ ... (${tree[dir].size - 3} more files)\n`;
      }
    });
    
    return result || 'No subdirectories found';
  }

  private getConfigDescription(filePath: string): string {
    const descriptions: { [key: string]: string } = {
      'package.json': 'Node.js dependencies and scripts',
      'tsconfig.json': 'TypeScript compilation settings',
      '.env': 'Environment variables',
      '.env.example': 'Environment variable template',
      'jest.config.js': 'Jest testing configuration'
    };
    
    const basename = path.basename(filePath);
    return descriptions[basename] || basename.replace(/\.[^.]+$/, '');
  }

  private slugify(text: string): string {
    return text
      .toLowerCase()
      .replace(/\s+/g, '-')
      .replace(/[^a-z0-9-]/g, '');
  }

  private formatBytes(bytes: number): string {
    if (bytes === 0) return '0 Bytes';
    const k = 1024;
    const sizes = ['Bytes', 'KB', 'MB', 'GB'];
    const i = Math.floor(Math.log(bytes) / Math.log(k));
    return parseFloat((bytes / Math.pow(k, i)).toFixed(2)) + ' ' + sizes[i];
  }

  private async generateDevelopmentGuide(
    repoStructure: RepoStructure,
    docsDir: string,
    verbose: boolean
  ): Promise<void> {
    if (verbose) {
      console.log(chalk.yellow('üõ†Ô∏è Generating development guide...'));
    }

    const developmentGuide = await this.createDevelopmentGuide(repoStructure);
    const devPath = path.join(docsDir, 'DEVELOPMENT.md');
    await fs.writeFile(devPath, developmentGuide);

    if (verbose) {
      console.log(chalk.green(`‚úÖ Development guide saved: ${devPath}`));
    }
  }

  private async generateDeploymentGuide(
    repoStructure: RepoStructure,
    docsDir: string,
    verbose: boolean
  ): Promise<void> {
    if (verbose) {
      console.log(chalk.yellow('üöÄ Generating deployment guide...'));
    }

    const deploymentGuide = await this.createDeploymentGuide(repoStructure);
    const deployPath = path.join(docsDir, 'DEPLOYMENT.md');
    await fs.writeFile(deployPath, deploymentGuide);

    if (verbose) {
      console.log(chalk.green(`‚úÖ Deployment guide saved: ${deployPath}`));
    }
  }

  private async generateTroubleshootingGuide(
    repoStructure: RepoStructure,
    docsDir: string,
    verbose: boolean
  ): Promise<void> {
    if (verbose) {
      console.log(chalk.yellow('üîß Generating troubleshooting guide...'));
    }

    const troubleshootingGuide = await this.createTroubleshootingGuide(repoStructure);
    const troublePath = path.join(docsDir, 'TROUBLESHOOTING.md');
    await fs.writeFile(troublePath, troubleshootingGuide);

    if (verbose) {
      console.log(chalk.green(`‚úÖ Troubleshooting guide saved: ${troublePath}`));
    }
  }

  private async createDevelopmentGuide(repoStructure: RepoStructure): Promise<string> {
    const moduleGroups = this.getModuleGroups(repoStructure);
    const configFiles = this.getConfigurationFiles(repoStructure);
    const packageInfo = this.getPackageInfo(repoStructure);

    const context = `Repository: ${repoStructure.rootPath}
Total Files: ${repoStructure.totalFiles}
Modules: ${moduleGroups.map(m => m.name).join(', ')}
Configuration Files: ${configFiles.map(f => path.basename(f.relativePath)).join(', ')}
Package Info: ${JSON.stringify(packageInfo, null, 2)}

Module Structure:
${moduleGroups.map(m => `- ${m.name}: ${m.description} (${m.files.length} files)`).join('\n')}`;

    return await this.llmClient.generateText(
      `Create a comprehensive development guide for this project. Include:

1. Getting Started (setup instructions)
2. Development Environment Requirements
3. Project Structure Overview
4. Development Workflow
5. Code Style and Standards
6. Testing Guidelines
7. Debugging Tips
8. Build Process
9. Contributing Guidelines

Format as clean Markdown with proper headings and code blocks.`,
      context
    );
  }

  private async createDeploymentGuide(repoStructure: RepoStructure): Promise<string> {
    const packageInfo = this.getPackageInfo(repoStructure);
    const configFiles = this.getConfigurationFiles(repoStructure);
    const hasDockerfile = repoStructure.files.some(f => f.relativePath.toLowerCase().includes('dockerfile'));
    const hasKubernetes = repoStructure.files.some(f => f.relativePath.includes('k8s') || f.relativePath.includes('kubernetes'));

    const context = `Repository: ${repoStructure.rootPath}
Package Info: ${JSON.stringify(packageInfo, null, 2)}
Configuration Files: ${configFiles.map(f => path.basename(f.relativePath)).join(', ')}
Has Dockerfile: ${hasDockerfile}
Has Kubernetes: ${hasKubernetes}
Project Type: ${this.detectProjectType(repoStructure)}`;

    return await this.llmClient.generateText(
      `Create a comprehensive deployment guide for this project. Include:

1. Prerequisites and Dependencies
2. Environment Configuration
3. Build Process for Production
4. Deployment Options (based on project type)
5. Environment Variables and Secrets
6. Database Setup (if applicable)
7. Monitoring and Health Checks
8. Rollback Procedures
9. Security Considerations
10. Performance Optimization

Adapt the guide based on the project type and available configuration files.
Format as clean Markdown with proper headings and code blocks.`,
      context
    );
  }

  private async createTroubleshootingGuide(repoStructure: RepoStructure): Promise<string> {
    const moduleGroups = this.getModuleGroups(repoStructure);
    const packageInfo = this.getPackageInfo(repoStructure);
    const projectType = this.detectProjectType(repoStructure);

    const context = `Repository: ${repoStructure.rootPath}
Project Type: ${projectType}
Package Info: ${JSON.stringify(packageInfo, null, 2)}
Modules: ${moduleGroups.map(m => `${m.name} (${m.files.length} files)`).join(', ')}`;

    return await this.llmClient.generateText(
      `Create a comprehensive troubleshooting guide for this ${projectType} project. Include:

1. Common Issues and Solutions
2. Development Environment Problems
3. Build and Compilation Errors
4. Runtime Errors and Debugging
5. Performance Issues
6. Dependency Problems
7. Configuration Issues
8. Testing Problems
9. Deployment Issues
10. Debugging Tools and Techniques
11. Log Analysis
12. FAQ Section

Focus on practical solutions and include code examples where helpful.
Format as clean Markdown with proper headings and code blocks.`,
      context
    );
  }

  private detectProjectType(repoStructure: RepoStructure): string {
    const packageJson = repoStructure.files.find(f => f.relativePath === 'package.json');
    if (packageJson) {
      return 'Node.js/JavaScript';
    }
    
    const cargoToml = repoStructure.files.find(f => f.relativePath === 'Cargo.toml');
    if (cargoToml) {
      return 'Rust';
    }
    
    const goMod = repoStructure.files.find(f => f.relativePath === 'go.mod');
    if (goMod) {
      return 'Go';
    }
    
    const pythonFiles = repoStructure.files.filter(f => f.extension === '.py');
    if (pythonFiles.length > 0) {
      return 'Python';
    }
    
    const javaFiles = repoStructure.files.filter(f => f.extension === '.java');
    if (javaFiles.length > 0) {
      return 'Java';
    }
    
    return 'Mixed/Other';
  }

  private getConfigurationFiles(repoStructure: RepoStructure): FileInfo[] {
    const configPatterns = [
      'package.json',
      'tsconfig.json',
      'jest.config.js',
      'webpack.config.js',
      '.env',
      '.env.example',
      'docker-compose.yml',
      'Dockerfile',
      'cargo.toml',
      'go.mod',
      'requirements.txt',
      'pyproject.toml'
    ];

    return repoStructure.files.filter((file: FileInfo) => 
      configPatterns.some(pattern => 
        file.relativePath.toLowerCase().includes(pattern.toLowerCase())
      )
    );
  }

  private getPackageInfo(repoStructure: RepoStructure): any {
    const packageJson = repoStructure.files.find(f => f.relativePath === 'package.json');
    if (packageJson) {
      try {
        // Read package.json content - this is a simplified approach
        // In practice, you might want to read the actual file content
        return {
          type: 'Node.js project',
          configFile: 'package.json',
          hasScripts: true
        };
      } catch {
        return { type: 'Node.js project', configFile: 'package.json' };
      }
    }

    const cargoToml = repoStructure.files.find(f => f.relativePath === 'Cargo.toml');
    if (cargoToml) {
      return { type: 'Rust project', configFile: 'Cargo.toml' };
    }

    const goMod = repoStructure.files.find(f => f.relativePath === 'go.mod');
    if (goMod) {
      return { type: 'Go project', configFile: 'go.mod' };
    }

    return { type: 'Generic project', configFile: 'none' };
  }
}