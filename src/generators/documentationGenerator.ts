import * as fs from 'fs-extra';
import * as path from 'path';
import { FileInfo, RepoStructure } from '../types';
import { FileMapper } from '../utils/fileMapper';
import { BaseLLMClient } from '../services/baseLLMClient';
import chalk from 'chalk';

interface ModuleGroup {
  name: string;
  description: string;
  files: FileInfo[];
}

export class DocumentationGenerator {
  constructor(
    private fileMapper: FileMapper,
    private llmClient: BaseLLMClient
  ) {}

  async generateDocumentation(
    repoStructure: RepoStructure,
    outputDir: string,
    verbose: boolean = false
  ): Promise<void> {
    const docsDir = path.join(outputDir, 'docs');
    await fs.ensureDir(docsDir);

    if (verbose) {
      console.log(chalk.blue(`üìö Generating documentation in: ${docsDir}`));
    }

    // Generate main documentation index
    await this.generateMainIndex(repoStructure, docsDir, verbose);

    // Generate overview documentation
    await this.generateOverview(repoStructure, docsDir, verbose);

    // Generate architecture documentation
    await this.generateArchitectureDoc(repoStructure, docsDir, verbose);

    // Generate module-based documentation
    await this.generateModuleDocumentation(repoStructure, docsDir, verbose);

    // Generate API reference
    await this.generateAPIReference(repoStructure, docsDir, verbose);

    // Generate configuration guide
    await this.generateConfigurationGuide(repoStructure, docsDir, verbose);
  }

  private async generateMainIndex(
    repoStructure: RepoStructure,
    docsDir: string,
    verbose: boolean
  ): Promise<void> {
    if (verbose) {
      console.log(chalk.yellow('üìù Generating documentation index...'));
    }

    const indexContent = `# Documentation Index

Welcome to the project documentation. This guide is organized into the following sections:

## üìö Documentation Structure

### [Overview](./overview.md)
High-level project overview, statistics, and key components.

### [Architecture](./architecture.md)
System architecture, design patterns, and technical decisions.

### [Modules](./modules/)
Detailed documentation for each module/component:
${this.getModuleGroups(repoStructure).map(group => 
  `- [${group.name}](./modules/${this.slugify(group.name)}.md) - ${group.description}`
).join('\n')}

### [API Reference](./api-reference.md)
Complete API documentation for all public interfaces.

### [Configuration](./configuration.md)
Configuration options, environment variables, and setup guides.

## üöÄ Quick Links

- [Getting Started](#getting-started)
- [Project Structure](./overview.md#project-structure)
- [Key Components](./architecture.md#key-components)
- [Contributing Guidelines](../CONTRIBUTING.md)

---
*Generated by AI Coders Context*
*Last updated: ${new Date().toISOString()}*
`;

    const indexPath = path.join(docsDir, 'README.md');
    await fs.writeFile(indexPath, indexContent);

    if (verbose) {
      console.log(chalk.green(`‚úÖ Documentation index saved: ${indexPath}`));
    }
  }

  private async generateOverview(
    repoStructure: RepoStructure,
    docsDir: string,
    verbose: boolean
  ): Promise<void> {
    if (verbose) {
      console.log(chalk.yellow('üìù Generating project overview...'));
    }

    const overview = await this.createEnhancedProjectOverview(repoStructure);
    const overviewPath = path.join(docsDir, 'overview.md');
    await fs.writeFile(overviewPath, overview);

    if (verbose) {
      console.log(chalk.green(`‚úÖ Project overview saved: ${overviewPath}`));
    }
  }

  private async generateArchitectureDoc(
    repoStructure: RepoStructure,
    docsDir: string,
    verbose: boolean
  ): Promise<void> {
    if (verbose) {
      console.log(chalk.yellow('üèóÔ∏è Generating architecture documentation...'));
    }

    const architecture = await this.createArchitectureDocumentation(repoStructure);
    const archPath = path.join(docsDir, 'architecture.md');
    await fs.writeFile(archPath, architecture);

    if (verbose) {
      console.log(chalk.green(`‚úÖ Architecture documentation saved: ${archPath}`));
    }
  }

  private async generateModuleDocumentation(
    repoStructure: RepoStructure,
    docsDir: string,
    verbose: boolean
  ): Promise<void> {
    const modulesDir = path.join(docsDir, 'modules');
    await fs.ensureDir(modulesDir);

    const moduleGroups = this.getModuleGroups(repoStructure);

    if (verbose) {
      console.log(chalk.yellow(`üì¶ Generating documentation for ${moduleGroups.length} modules...`));
    }

    for (const module of moduleGroups) {
      try {
        const moduleDoc = await this.createModuleDocumentation(module, repoStructure);
        const modulePath = path.join(modulesDir, `${this.slugify(module.name)}.md`);
        await fs.writeFile(modulePath, moduleDoc);

        if (verbose) {
          console.log(chalk.green(`‚úÖ Module documentation generated: ${module.name}`));
        }
      } catch (error) {
        if (verbose) {
          console.log(chalk.red(`‚ùå Error documenting module ${module.name}: ${error}`));
        }
      }
    }
  }

  private async generateAPIReference(
    repoStructure: RepoStructure,
    docsDir: string,
    verbose: boolean
  ): Promise<void> {
    if (verbose) {
      console.log(chalk.yellow('üîå Generating API reference...'));
    }

    const apiRef = await this.createAPIReference(repoStructure);
    const apiPath = path.join(docsDir, 'api-reference.md');
    await fs.writeFile(apiPath, apiRef);

    if (verbose) {
      console.log(chalk.green(`‚úÖ API reference saved: ${apiPath}`));
    }
  }

  private async generateConfigurationGuide(
    repoStructure: RepoStructure,
    docsDir: string,
    verbose: boolean
  ): Promise<void> {
    if (verbose) {
      console.log(chalk.yellow('‚öôÔ∏è Generating configuration guide...'));
    }

    const configGuide = await this.createConfigurationGuide(repoStructure);
    const configPath = path.join(docsDir, 'configuration.md');
    await fs.writeFile(configPath, configGuide);

    if (verbose) {
      console.log(chalk.green(`‚úÖ Configuration guide saved: ${configPath}`));
    }
  }

  private getModuleGroups(repoStructure: RepoStructure): ModuleGroup[] {
    const groups: Map<string, FileInfo[]> = new Map();
    
    // Group files by their top-level directory or logical module
    repoStructure.files.forEach(file => {
      if (!this.fileMapper.isTextFile(file.path)) return;
      
      const parts = file.relativePath.split(path.sep);
      let groupName = 'Root Files';
      
      if (parts.length > 1) {
        groupName = parts[0];
        // Special handling for src files
        if (groupName === 'src' && parts.length > 2) {
          groupName = `${parts[1]}`;
        }
      }
      
      if (!groups.has(groupName)) {
        groups.set(groupName, []);
      }
      groups.get(groupName)!.push(file);
    });

    // Convert to ModuleGroup array with descriptions
    return Array.from(groups.entries()).map(([name, files]) => ({
      name: this.formatModuleName(name),
      description: this.getModuleDescription(name, files),
      files
    })).sort((a, b) => a.name.localeCompare(b.name));
  }

  private formatModuleName(name: string): string {
    return name
      .split(/[-_]/)
      .map(word => word.charAt(0).toUpperCase() + word.slice(1))
      .join(' ');
  }

  private getModuleDescription(name: string, files: FileInfo[]): string {
    const descriptions: { [key: string]: string } = {
      'generators': 'Code generation utilities for documentation and agents',
      'services': 'External service integrations and API clients',
      'utils': 'Utility functions and helper modules',
      'types': 'TypeScript type definitions and interfaces',
      'Root Files': 'Main configuration and entry point files'
    };

    return descriptions[name] || `${this.formatModuleName(name)} module with ${files.length} files`;
  }

  private async createModuleDocumentation(
    module: ModuleGroup,
    repoStructure: RepoStructure
  ): Promise<string> {
    const fileContents: string[] = [];
    
    for (const file of module.files.slice(0, 10)) { // Limit to prevent too large requests
      const content = await this.fileMapper.readFileContent(file.path);
      fileContents.push(`File: ${file.relativePath}\n${content.substring(0, 1000)}...`);
    }

    const moduleContext = `Module: ${module.name}
Description: ${module.description}
Files: ${module.files.map(f => f.relativePath).join(', ')}

Sample content from module files:
${fileContents.join('\n\n---\n\n')}`;

    const documentation = await this.llmClient.generateText(
      `Generate comprehensive documentation for this module. Include:
1. Module overview and purpose
2. Key components and their responsibilities
3. Public APIs and interfaces
4. Usage examples
5. Dependencies and relationships

Module context:
${moduleContext}`,
      'You are a technical documentation expert. Create clear, well-structured module documentation.'
    );

    return `# ${module.name}

${documentation}

## Files in this module

${module.files.map(file => `- \`${file.relativePath}\` - ${this.formatBytes(file.size)}`).join('\n')}

---
*Generated by AI Coders Context*
`;
  }

  private async createEnhancedProjectOverview(repoStructure: RepoStructure): Promise<string> {
    const { files, directories, totalFiles, totalSize } = repoStructure;
    
    const extensions = new Map<string, number>();
    files.forEach(file => {
      const ext = file.extension || 'no-extension';
      extensions.set(ext, (extensions.get(ext) || 0) + 1);
    });

    const topExtensions = Array.from(extensions.entries())
      .sort((a, b) => b[1] - a[1])
      .slice(0, 10);

    // Try to identify project type
    const projectType = this.identifyProjectType(repoStructure);
    const techStack = this.identifyTechStack(repoStructure);

    return `# Project Overview

## Project Information
- **Type**: ${projectType}
- **Technology Stack**: ${techStack.join(', ')}
- **Total Files**: ${totalFiles}
- **Total Size**: ${this.formatBytes(totalSize)}

## Project Structure

### Directory Overview
\`\`\`
${this.createSimplifiedTree(repoStructure)}
\`\`\`

### File Distribution
${topExtensions.map(([ext, count]) => `- **${ext}**: ${count} files (${((count/totalFiles)*100).toFixed(1)}%)`).join('\n')}

## Key Files
${this.identifyKeyFiles(repoStructure).map(f => `- \`${f.relativePath}\` - ${f.description}`).join('\n')}

## Development Setup

Refer to the [Configuration Guide](./configuration.md) for detailed setup instructions.

---
*Generated by AI Coders Context*
`;
  }

  private async createArchitectureDocumentation(repoStructure: RepoStructure): Promise<string> {
    const modules = this.getModuleGroups(repoStructure);
    const techStack = this.identifyTechStack(repoStructure);

    return `# Architecture Documentation

## System Overview

This document describes the high-level architecture of the project.

## Technology Stack

${techStack.map(tech => `- **${tech}**`).join('\n')}

## Component Architecture

### Core Modules

${modules.map(module => `#### ${module.name}
- **Purpose**: ${module.description}
- **Files**: ${module.files.length}
- **Key Responsibilities**: [To be analyzed]
`).join('\n')}

## Design Patterns

Based on the codebase structure, the following patterns are identified:
- Command Pattern (CLI structure)
- Service Layer Pattern (services directory)
- Factory Pattern (generators)

## Data Flow

1. **Input Processing**: Command-line arguments are parsed
2. **File Analysis**: Repository structure is mapped
3. **Content Generation**: LLM-based documentation generation
4. **Output Generation**: Structured documentation output

## Dependencies

Analyze package.json for detailed dependency information.

---
*Generated by AI Coders Context*
`;
  }

  private async createAPIReference(repoStructure: RepoStructure): Promise<string> {
    const apiFiles = repoStructure.files.filter(f => 
      f.relativePath.includes('types') || 
      f.relativePath.includes('index') ||
      f.relativePath.endsWith('.ts')
    );

    return `# API Reference

## Overview

This document provides a complete reference for all public APIs in the project.

## Core APIs

### CLI Commands

#### \`generate\`
Generate documentation and agent prompts for a repository.

**Usage:**
\`\`\`bash
ai-context generate <repo-path> [options]
\`\`\`

**Options:**
- \`-o, --output <dir>\`: Output directory
- \`-k, --api-key <key>\`: OpenRouter API key
- \`-m, --model <model>\`: LLM model to use
- \`--exclude <patterns...>\`: Patterns to exclude
- \`--include <patterns...>\`: Patterns to include

#### \`analyze\`
Analyze repository structure without generating content.

**Usage:**
\`\`\`bash
ai-context analyze <repo-path> [options]
\`\`\`

## Module APIs

${this.getModuleGroups(repoStructure).map(module => 
  `### ${module.name}\nSee [${module.name} Module Documentation](./modules/${this.slugify(module.name)}.md)`
).join('\n\n')}

## Type Definitions

See the types module for detailed interface definitions.

---
*Generated by AI Coders Context*
`;
  }

  private async createConfigurationGuide(repoStructure: RepoStructure): Promise<string> {
    const configFiles = repoStructure.files.filter(f => 
      f.relativePath.includes('config') ||
      f.relativePath.includes('.json') ||
      f.relativePath.includes('.env')
    );

    return `# Configuration Guide

## Environment Variables

### Required Variables

- \`OPENROUTER_API_KEY\`: Your OpenRouter API key for LLM access

### Optional Variables

- \`OPENROUTER_MODEL\`: Override default model (default: \`google/gemini-2.0-pro\`)
- \`OPENROUTER_BASE_URL\`: Custom API endpoint (rarely needed)

## Configuration Files

${configFiles.map(f => `### ${f.relativePath}
Configuration file for ${this.getConfigDescription(f.relativePath)}`).join('\n\n')}

## Setup Instructions

1. **Clone the repository**
   \`\`\`bash
   git clone https://github.com/vinilana/ai-coders-context.git
   cd ai-coders-context
   \`\`\`

2. **Install dependencies**
   \`\`\`bash
   npm install
   \`\`\`

3. **Configure environment**
   \`\`\`bash
   cp .env.example .env
   # Edit .env with your API key
   \`\`\`

4. **Build the project**
   \`\`\`bash
   npm run build
   \`\`\`

## Advanced Configuration

### Custom Model Selection

You can use any model available on OpenRouter:
- \`anthropic/claude-3-haiku\` - Fast and efficient
- \`anthropic/claude-3-sonnet\` - Balanced performance
- \`openai/gpt-4\` - High quality output
- \`google/gemini-2.0-pro\` - Google's latest model

### Output Customization

Control what gets generated:
- \`--docs-only\`: Generate only documentation
- \`--agents-only\`: Generate only agent prompts
- \`--exclude\`: Exclude specific file patterns
- \`--include\`: Include only specific patterns

---
*Generated by AI Coders Context*
`;
  }

  private identifyProjectType(repoStructure: RepoStructure): string {
    const files = repoStructure.files.map(f => f.relativePath);
    
    if (files.some(f => f === 'package.json')) {
      if (files.some(f => f.includes('react') || f.includes('.jsx') || f.includes('.tsx'))) {
        return 'React Application';
      } else if (files.some(f => f.includes('angular.json'))) {
        return 'Angular Application';
      } else if (files.some(f => f.includes('vue'))) {
        return 'Vue Application';
      } else if (files.some(f => f.includes('next.config'))) {
        return 'Next.js Application';
      }
      return 'Node.js Project';
    } else if (files.some(f => f === 'requirements.txt' || f === 'setup.py')) {
      return 'Python Project';
    } else if (files.some(f => f === 'pom.xml')) {
      return 'Java Maven Project';
    } else if (files.some(f => f === 'build.gradle')) {
      return 'Java Gradle Project';
    }
    
    return 'General Software Project';
  }

  private identifyTechStack(repoStructure: RepoStructure): string[] {
    const stack: string[] = [];
    const files = repoStructure.files.map(f => f.relativePath);
    
    // Languages
    if (files.some(f => f.endsWith('.ts') || f.endsWith('.tsx'))) stack.push('TypeScript');
    if (files.some(f => f.endsWith('.js') || f.endsWith('.jsx'))) stack.push('JavaScript');
    if (files.some(f => f.endsWith('.py'))) stack.push('Python');
    if (files.some(f => f.endsWith('.java'))) stack.push('Java');
    
    // Frameworks
    if (files.some(f => f === 'package.json')) stack.push('Node.js');
    if (files.some(f => f.includes('react'))) stack.push('React');
    if (files.some(f => f.includes('vue'))) stack.push('Vue');
    if (files.some(f => f.includes('angular'))) stack.push('Angular');
    
    // Tools
    if (files.some(f => f === 'tsconfig.json')) stack.push('TypeScript Compiler');
    if (files.some(f => f === 'jest.config.js')) stack.push('Jest');
    if (files.some(f => f === 'webpack.config.js')) stack.push('Webpack');
    
    return [...new Set(stack)];
  }

  private identifyKeyFiles(repoStructure: RepoStructure): Array<{relativePath: string, description: string}> {
    const keyFiles: Array<{relativePath: string, description: string}> = [];
    
    repoStructure.files.forEach(file => {
      const basename = path.basename(file.path);
      const descriptions: { [key: string]: string } = {
        'package.json': 'Node.js project configuration and dependencies',
        'tsconfig.json': 'TypeScript compiler configuration',
        'README.md': 'Project documentation and setup guide',
        '.gitignore': 'Git ignore patterns',
        'LICENSE': 'Project license information',
        'index.ts': 'Main entry point',
        'index.js': 'Main entry point',
        '.env.example': 'Environment variable template'
      };
      
      if (descriptions[basename]) {
        keyFiles.push({
          relativePath: file.relativePath,
          description: descriptions[basename]
        });
      }
    });
    
    return keyFiles;
  }

  private createSimplifiedTree(repoStructure: RepoStructure): string {
    const tree: { [key: string]: Set<string> } = {};
    
    // Build directory structure
    repoStructure.files.forEach(file => {
      const parts = file.relativePath.split(path.sep);
      if (parts.length > 1) {
        const dir = parts[0];
        if (!tree[dir]) tree[dir] = new Set();
        if (parts.length === 2) {
          tree[dir].add(parts[1]);
        }
      }
    });
    
    // Create tree visualization
    let result = '';
    const dirs = Object.keys(tree).sort();
    
    dirs.forEach((dir, index) => {
      const isLast = index === dirs.length - 1;
      result += `${isLast ? '‚îî‚îÄ‚îÄ ' : '‚îú‚îÄ‚îÄ '}${dir}/\n`;
      
      const files = Array.from(tree[dir]).slice(0, 3);
      files.forEach((file, fIndex) => {
        const isLastFile = fIndex === files.length - 1 && tree[dir].size <= 3;
        result += `${isLast ? '    ' : '‚îÇ   '}${isLastFile ? '‚îî‚îÄ‚îÄ ' : '‚îú‚îÄ‚îÄ '}${file}\n`;
      });
      
      if (tree[dir].size > 3) {
        result += `${isLast ? '    ' : '‚îÇ   '}‚îî‚îÄ‚îÄ ... (${tree[dir].size - 3} more files)\n`;
      }
    });
    
    return result || 'No subdirectories found';
  }

  private getConfigDescription(filePath: string): string {
    const descriptions: { [key: string]: string } = {
      'package.json': 'Node.js dependencies and scripts',
      'tsconfig.json': 'TypeScript compilation settings',
      '.env': 'Environment variables',
      '.env.example': 'Environment variable template',
      'jest.config.js': 'Jest testing configuration'
    };
    
    const basename = path.basename(filePath);
    return descriptions[basename] || basename.replace(/\.[^.]+$/, '');
  }

  private slugify(text: string): string {
    return text
      .toLowerCase()
      .replace(/\s+/g, '-')
      .replace(/[^a-z0-9-]/g, '');
  }

  private formatBytes(bytes: number): string {
    if (bytes === 0) return '0 Bytes';
    const k = 1024;
    const sizes = ['Bytes', 'KB', 'MB', 'GB'];
    const i = Math.floor(Math.log(bytes) / Math.log(k));
    return parseFloat((bytes / Math.pow(k, i)).toFixed(2)) + ' ' + sizes[i];
  }
}